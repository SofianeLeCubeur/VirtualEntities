package com.github.sofianelecubeur.virtualentities.test;

import java.awt.Color;
import java.awt.image.BufferedImage;
import java.util.Arrays;

/**
 * Container class for images
 * <p>
 * Stores colors as an integer array
 * @author InventivetalentDev
 */
public class ArrayImage {

	private int[] array;
	private int   width;
	private int   height;

	public int minX = 0;
	public int minY = 0;
	public int maxX = 128;
	public int maxY = 128;

	//Only used if the cache is enabled
	private Object packetData;

	private int imageType = BufferedImage.TYPE_4BYTE_ABGR;

	protected ArrayImage(int[] array) {
		this.array = array;
	}

	/**
	 * Convert a {@link BufferedImage} to an ArrayImage
	 *
	 * @param image image to convert
	 */
	public ArrayImage(BufferedImage image) {
		this.imageType = image.getType();

		this.width = image.getWidth();
		this.height = image.getHeight();
		//		int[][] intArray = ImageToMultiArray(image);
		//		int length = width * height;
		//		this.array = new int[length];
		//		for (int x = 0; x < intArray.length; x++) {
		//			for (int y = 0; y < intArray[x].length; y++) {
		//				array[y * image.getWidth() + x] = intArray[x][y];
		//			}
		//		}
		this.array = ImageToArray(image);
	}

	/**
	 * Construct an ArrayImage from raw data
	 *
	 * @param data raw image data
	 */
	public ArrayImage(int[][] data) {
		this.array = new int[data.length * data[0].length];
		this.width = data.length;
		this.height = data[0].length;
		for (int x = 0; x < data.length; x++) {
			for (int y = 0; y < data[x].length; y++) {
				array[y * data.length + x] = data[x][y];
			}
		}
	}

	public int[] getData() {
		return array;
	}

	public ArrayImage updateSection(int xOffset, int yOffset, BufferedImage image) {
		return updateSection(xOffset, yOffset, ImageToMultiArray(image));
	}

	public ArrayImage updateSection(int xOffset, int yOffset, int[][] intArray) {
		int[] arrayClone = new int[this.array.length];
		System.arraycopy(this.array, 0, arrayClone, 0, this.array.length);

		for (int x = 0; x < intArray.length; x++) {
			for (int y = 0; y < intArray[x].length; y++) {
				arrayClone[(y + yOffset) * intArray.length + (x + xOffset)] = intArray[x][y];
			}
		}

		ArrayImage newImage = new ArrayImage(arrayClone);
		newImage.width = this.width;
		newImage.height = this.height;

		// Section
		newImage.minX = xOffset;
		newImage.minY = yOffset;
		newImage.maxX = intArray.length;
		newImage.maxY = intArray[0].length;

		return newImage;
	}

	final boolean newerThan1_8 = true;

	/**
	 * @return the generated byte data-array for the map packet
	 */
	public Object generatePacketData() {
		if (this.packetData != null) { return this.packetData; }

		Object dataObject;

		byte[] data = new byte[128 * 128];
		//			Arrays.fill(data, (byte) 0);
		for (int x = 0; x < 128; x++) {
			for (int y = 0; y < 128; y++) {
				data[y * 128 + x] = matchColor(new Color(getRGB(x, y), true));
			}
		}

		dataObject = data;
		this.packetData = dataObject;
		return this.packetData;
	}

	/**
	 * @param x x-pixel
	 * @param y y-pixel
	 * @return the RGB-value at the specified position
	 */
	public int getRGB(int x, int y) {
		return array[y * width + x];
	}

	/**
	 * @return the width of the image
	 */
	public int getWidth() {
		return width;
	}

	/**
	 * @return the height of the image
	 */
	public int getHeight() {
		return height;
	}

	/**
	 * Convert this image back to a {@link BufferedImage}
	 *
	 * @return new {@link BufferedImage}
	 */
	public BufferedImage toBuffered() {
		BufferedImage image = new BufferedImage(getWidth(), getHeight(), this.imageType);
		for (int x = 0; x < width; x++) {
			for (int y = 0; y < height; y++) {
				image.setRGB(x, y, array[y * getWidth() + x]);
			}
		}
		return image;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) { return true; }
		if (o == null || getClass() != o.getClass()) { return false; }

		ArrayImage that = (ArrayImage) o;

		if (width != that.width) { return false; }
		if (height != that.height) { return false; }
		return Arrays.equals(array, that.array);

	}

	@Override
	public int hashCode() {
		int result = array != null ? Arrays.hashCode(array) : 0;
		result = 31 * result + width;
		result = 31 * result + height;
		return result;
	}

	protected static int[][] ImageToMultiArray(BufferedImage image) {
		int[][] array = new int[image.getWidth()][image.getHeight()];
		for (int x = 0; x < image.getWidth(); x++) {
			for (int y = 0; y < image.getHeight(); y++) {
				array[x][y] = image.getRGB(x, y);
			}
		}
		return array;
	}

	protected static int[] ImageToArray(BufferedImage image) {
		int[] array = new int[image.getWidth() * image.getHeight()];
		for (int x = 0; x < image.getWidth(); x++) {
			for (int y = 0; y < image.getHeight(); y++) {
				array[y * image.getWidth() + x] = image.getRGB(x, y);
			}
		}
		return array;
	}

	protected static boolean ImageContentEqual(BufferedImage b1, BufferedImage b2) {
		if (b1 == null || b2 == null) { return false; }
		// if (b1.equals(b2)) return true;
		if (b1.getWidth() != b2.getWidth()) { return false; }
		if (b1.getHeight() != b2.getHeight()) { return false; }
		for (int y = 0; y < b1.getHeight(); y++) {
			for (int x = 0; x < b1.getWidth(); x++) {
				if (b1.getRGB(x, y) != b2.getRGB(x, y)) { return false; }
			}
		}
		return true;
	}

	protected static boolean ImageContentEqual(ArrayImage b1, ArrayImage b2) {
		if (b1 == null || b2 == null) { return false; }
		// if (b1.equals(b2)) return true;
		if (b1.getWidth() != b2.getWidth()) { return false; }
		if (b1.getHeight() != b2.getHeight()) { return false; }
		for (int y = 0; y < b1.getHeight(); y++) {
			for (int x = 0; x < b1.getWidth(); x++) {
				if (b1.getRGB(x, y) != b2.getRGB(x, y)) { return false; }
			}
		}
		return true;
	}
	
	protected static byte matchColor(int rgb) {
		int index = 0;
		double best = -1.0D;
		for (int i = 4; i < MAP_COLORS.length; i++) {
			double distance = getDistance(rgb, MAP_COLORS[i].getRGB());
			if (distance < best || best == -1.0D) {
				best = distance;
				index = i;
			}
		}
		return (byte) (index < 128 ? index : -129 + index - 127);
	}

	protected static byte matchColor(Color color) {
		if (color.getAlpha() < 128) { return 0; }
		int index = 0;
		double best = -1.0D;
		for (int i = 4; i < MAP_COLORS.length; i++) {
			double distance = getDistance(color, MAP_COLORS[i]);
			if (distance < best || best == -1.0D) {
				best = distance;
				index = i;
			}
		}
		return (byte) (index < 128 ? index : -129 + index - 127);
	}
	
	protected static double getDistance(int r1, int g1, int b1, int r2, int g2, int b2) {
		double rmean = (r1 + r2) / 2.0D;
		double r = r1 - r2;
		double g = g1 - g2;
		int b = b1 - b2;
		double weightR = 2.0D + rmean / 256.0D;
		double weightG = 4.0D;
		double weightB = 2.0D + (255.0D - rmean) / 256.0D;
		return weightR * r * r + weightG * g * g + weightB * b * b;
	}

	protected static double getDistance(int rgb1, int rgb2) {
		int r1 = (rgb1 >> 16) & 0x000000FF;
		int g1 = (rgb1 >> 8) & 0x000000FF;
		int b1 = (rgb1) & 0x000000FF;

		int r2 = (rgb2 >> 16) & 0x000000FF;
		int g2 = (rgb2 >> 8) & 0x000000FF;
		int b2 = (rgb2) & 0x000000FF;

		return getDistance(r1, g1, b1, r2, g2, b2);
	}

	protected static double getDistance(Color c1, Color c2) {
		return getDistance(c1.getRed(), c1.getGreen(), c1.getBlue(), c2.getRed(), c2.getGreen(), c2.getBlue());
	}
	
	protected static final Color[] MAP_COLORS = new Color[] {
			c(0, 0, 0),
			c(0, 0, 0),
			c(0, 0, 0),
			c(0, 0, 0),
			c(89, 125, 39),
			c(109, 153, 48),
			c(127, 178, 56),
			c(67, 94, 29),
			c(174, 164, 115),
			c(213, 201, 140),
			c(247, 233, 163),
			c(130, 123, 86),
			c(140, 140, 140),
			c(171, 171, 171),
			c(199, 199, 199),
			c(105, 105, 105),
			c(180, 0, 0),
			c(220, 0, 0),
			c(255, 0, 0),
			c(135, 0, 0),
			c(112, 112, 180),
			c(138, 138, 220),
			c(160, 160, 255),
			c(84, 84, 135),
			c(117, 117, 117),
			c(144, 144, 144),
			c(167, 167, 167),
			c(88, 88, 88),
			c(0, 87, 0),
			c(0, 106, 0),
			c(0, 124, 0),
			c(0, 65, 0),
			c(180, 180, 180),
			c(220, 220, 220),
			c(255, 255, 255),
			c(135, 135, 135),
			c(115, 118, 129),
			c(141, 144, 158),
			c(164, 168, 184),
			c(86, 88, 97),
			c(106, 76, 54),
			c(130, 94, 66),
			c(151, 109, 77),
			c(79, 57, 40),
			c(79, 79, 79),
			c(96, 96, 96),
			c(112, 112, 112),
			c(59, 59, 59),
			c(45, 45, 180),
			c(55, 55, 220),
			c(64, 64, 255),
			c(33, 33, 135),
			c(100, 84, 50),
			c(123, 102, 62),
			c(143, 119, 72),
			c(75, 63, 38),
			c(180, 177, 172),
			c(220, 217, 211),
			c(255, 252, 245),
			c(135, 133, 129),
			c(152, 89, 36),
			c(186, 109, 44),
			c(216, 127, 51),
			c(114, 67, 27),
			c(125, 53, 152),
			c(153, 65, 186),
			c(178, 76, 216),
			c(94, 40, 114),
			c(72, 108, 152),
			c(88, 132, 186),
			c(102, 153, 216),
			c(54, 81, 114),
			c(161, 161, 36),
			c(197, 197, 44),
			c(229, 229, 51),
			c(121, 121, 27),
			c(89, 144, 17),
			c(109, 176, 21),
			c(127, 204, 25),
			c(67, 108, 13),
			c(170, 89, 116),
			c(208, 109, 142),
			c(242, 127, 165),
			c(128, 67, 87),
			c(53, 53, 53),
			c(65, 65, 65),
			c(76, 76, 76),
			c(40, 40, 40),
			c(108, 108, 108),
			c(132, 132, 132),
			c(153, 153, 153),
			c(81, 81, 81),
			c(53, 89, 108),
			c(65, 109, 132),
			c(76, 127, 153),
			c(40, 67, 81),
			c(89, 44, 125),
			c(109, 54, 153),
			c(127, 63, 178),
			c(67, 33, 94),
			c(36, 53, 125),
			c(44, 65, 153),
			c(51, 76, 178),
			c(27, 40, 94),
			c(72, 53, 36),
			c(88, 65, 44),
			c(102, 76, 51),
			c(54, 40, 27),
			c(72, 89, 36),
			c(88, 109, 44),
			c(102, 127, 51),
			c(54, 67, 27),
			c(108, 36, 36),
			c(132, 44, 44),
			c(153, 51, 51),
			c(81, 27, 27),
			c(17, 17, 17),
			c(21, 21, 21),
			c(25, 25, 25),
			c(13, 13, 13),
			c(176, 168, 54),
			c(215, 205, 66),
			c(250, 238, 77),
			c(132, 126, 40),
			c(64, 154, 150),
			c(79, 188, 183),
			c(92, 219, 213),
			c(48, 115, 112),
			c(52, 90, 180),
			c(63, 110, 220),
			c(74, 128, 255),
			c(39, 67, 135),
			c(0, 153, 40),
			c(0, 187, 50),
			c(0, 217, 58),
			c(0, 114, 30),
			c(91, 60, 34),
			c(111, 74, 42),
			c(129, 86, 49),
			c(68, 45, 25),
			c(79, 1, 0),
			c(96, 1, 0),
			c(112, 2, 0),
			c(59, 1, 0) };
	
	private static Color c(int r, int g, int b) {
		return new Color(r, g, b);
	}
}